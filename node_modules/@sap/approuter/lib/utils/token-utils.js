/* eslint-disable camelcase */
'use strict';

const xsenv = require('@sap/xsenv');
const validators = require('../configuration/validators');
const passportUtils = require('../passport/utils');
const loggerUtils = require('./logger');
const tracer = loggerUtils.getTracer(__filename);
const urijs = require('urijs');
const url = require('url');
const request = require('request');
const NodeCache = require('node-cache');
const xssec = require('@sap/xssec');
const jarCache = new NodeCache({stdTTL: 300, checkperiod: 320, useClones: false});
const iasUtils = require('../utils/ias-utils');
const jwtDecode = require('jwt-decode');
const cacheKey = 'kibanaJar';

exports.getTokens = getBSTokens;
exports.loadClientCredentialsToken = loadClientCredentialsToken;
exports.getClientCredentialsTokenByTenant = getClientCredentialsTokenByTenant;
exports.getAuthenticationJar = getAuthenticationJar;
exports.exchangeToken = exchangeToken;

function getBSTokens(app) {
  const DESTINATION = 'destination';
  const CONNECTIVITY = 'connectivity';
  const CLIENT_CREDENTIALS = 'client_credentials';

  const services = xsenv.readServices();
  if (services) {
    for (const serviceName in services) {
      const service = services[serviceName];
      if (service.label === DESTINATION || service.label === CONNECTIVITY || (service.credentials && service.credentials['grant_type'] === CLIENT_CREDENTIALS)) {
        validators.validateClientCredentials(service.credentials);
        loadClientCredentialsToken(app, service.credentials, service.credentials['sap.cloud.service'] || service.label);
      }
    }
  }
}

function getClientCredentialsTokenByTenant(tenant, credentials, cb) {
  const zoneId = iasUtils.getTenantComponents(tenant).zoneId;
  const targetTenantUrl = !zoneId ? credentials.url.replace(credentials.identityzone, tenant) : 'https://' + credentials.uaadomain;
  const requestOptions = {
    url: (targetTenantUrl) + '/oauth/token/?grant_type=client_credentials',
    headers: {
      'content-type': 'application/x-www-form-urlencoded;charset=utf-8',
      'accept': 'application/json;charset=utf-8'
    },
    auth: {
      user: credentials.clientid || credentials.uaa.clientid,
      pass: credentials.clientsecret || credentials.uaa.clientsecret
    }
  };
  if (zoneId) {
    requestOptions.headers['x-zid'] = zoneId;
  }
  passportUtils.callUaa(requestOptions, null, function(err, uaaResponse) {
    if (err) {
      tracer.error('Error getting ' + credentials.label + ' client credentials from UAA. Number of attempts done: %d, error: %s', passportUtils.MAX_ATTEMPTS_NUMBER, err.message);
      return cb ? cb(err) : null;
    }
    if (!uaaResponse.access_token || !uaaResponse.expires_in) {
      tracer.error('Bad response from UAA when getting client credentials token for ' + credentials.label + ' - not all fields are present');
      return cb ? cb(new Error('Bad response from UAA when getting client credentials token for ' + credentials.label + ' - not all fields are present')) : null;
    }
    const result = {
      accessToken: uaaResponse.access_token,
      tokenType: uaaResponse.token_type,
      tokenRefreshTimestamp: passportUtils.getExpiresAt(uaaResponse.expires_in).getTime()
    };
    return cb(null, result);
  });
}

function loadClientCredentialsToken(app, credentials, serviceName, cb) {
  let url = credentials.url || credentials.uaa.url;
  const parsedUrl = urijs.parse(url);
  url = parsedUrl.path !== '/' ? url : url + '/oauth/token/';
  const requestOptions = {
    url: url + '?grant_type=client_credentials',
    headers: {
      'content-type': 'application/x-www-form-urlencoded;charset=utf-8',
      'accept': 'application/json;charset=utf-8'
    },
    auth: {
      user: credentials.clientid || credentials.uaa.clientid,
      pass: credentials.clientsecret || credentials.uaa.clientsecret
    }
  };

  passportUtils.callUaa(requestOptions, null, function(err, uaaResponse) {
    if (err) {
      tracer.error('Error getting ' + credentials.label + ' client credentials from UAA. Number of attempts done: %d, error: %s', passportUtils.MAX_ATTEMPTS_NUMBER, err.message);
      return cb ? cb(err) : null;
    }
    if (!uaaResponse.access_token || !uaaResponse.expires_in) {
      tracer.error('Bad response from UAA when getting client credentials token for ' + credentials.label + ' - not all fields are present');
      return cb ? cb(new Error('Bad response from UAA when getting client credentials token for ' + credentials.label + ' - not all fields are present')) : null;
    }
    const options = {
      accessToken: uaaResponse.access_token,
      tokenType: uaaResponse.token_type,
      tokenRefreshTimestamp: passportUtils.getExpiresAt(uaaResponse.expires_in).getTime()
    };

    if (!app.services) { app.services = {}; }

    app.services[serviceName] = { token: options };
    const FIVE_MINUTES = 5 * 60 * 1000;
    const tokenRefreshTimestamp = passportUtils.getExpiresAt(uaaResponse.expires_in).getTime() - FIVE_MINUTES;
    const msBeforeRetrieval = tokenRefreshTimestamp - Date.now();
    setTimeout(function() { loadClientCredentialsToken(app, credentials, serviceName); }, msBeforeRetrieval);
    return cb ? cb() : null;
  });
}

function getAuthenticationJar(cb) {
  const cachedJar = jarCache.get(cacheKey);
  if (cachedJar && cachedJar._jar && cachedJar._jar.store) {
    return cb(null, cachedJar);
  }
  const requestOptions = {
    url: process.env.UAA_URL + '/oauth/token?login_hint=%7B%22origin%22%3A%22sap.ids%22%7D',
    form: {
      username: process.env.UAA_USER,
      password: process.env.UAA_PASSWORD,
      client_id: 'cf',
      client_secret: '',
      'grant_type': 'password',
      response_type: 'token'
    },
    timeout: 10000
  };

  request.post(requestOptions, function onResponse(err, res, body) {
    let accessToken = null;
    if (err || !body) {
      const error = new Error('Failed to get UAA token ' + err + ' ' + body ? body : '');
      error.status = 403;
      return cb(error);
    }
    try {
      accessToken = JSON.parse(body).access_token;
      const jar = request.jar();
      getState(accessToken, jar, function(err, state, jar) {
        if (err) {
          return cb(err);
        }
        return getJarContent(jar, state, accessToken, cb);
      });
    } catch (err) {
      return cb(new Error('Failed to parse UAA token ' + err + ' ' + accessToken));
    }
  });
}

function getState(accessToken, jar, cb) {
  const url = process.env.LOGS_URL + '/app/kibana#/discover';
  const requestOptions = {
    url: url,
    jar: jar,
    followRedirect: false
  };
  request.get(requestOptions, function onResponse(err, res, body) {
    const stateIndex = body.indexOf(';state=');
    if (stateIndex === -1) {
      return cb(new Error('No state variable found in discovery for url: ' + url + ', response was: ' + res.body));
    }
    // eslint-disable-next-line no-useless-escape
    const stateFinished = body.indexOf('\">');
    const state = body.substring(stateIndex + 7, stateFinished);
    cb(null, state, jar);
  });
}
function getClientId(cb) {
  request.get({url: process.env.LOGS_URL, followRedirect: false}, (err, response) => {
    if (err || response.statusCode !== 302) {
      return cb(err);
    }
    const query = url.parse(response.headers.location, true).query;
    cb(null, query.client_id);
  });
}
function getJarContent(jar, state, accessToken, cb) {
  getClientId((err, clientID) => {
    // eslint-disable-next-line nodejs/align-multiline-assignment
    const url = process.env.UAA_URL + '/oauth/authorize?grant_type=authorization_code&client_id=' +
        clientID + '&response_type=code&state=' + state +
        '&login_hint=%7B%22origin%22%3A%22uaa%22%7D&redirect_uri=' +
        encodeURIComponent(process.env.LOGS_URL + '/authorization');
    const requestOptions = {
      url: url,
      jar: jar,
      headers: {
        Authorization: 'bearer ' + accessToken
      }
    };
    request.get(requestOptions, function onResponse(err) {
      if (err) {
        return cb(err);
      }
      jarCache.set(cacheKey, jar);
      cb(null, jar);
    });
  });
}

function exchangeToken(loginToken, externalServiceCredentials, cb) {
  if (xssec.requests.requestUserToken.isSinonProxy || process.env.NODE_ENV === 'development') {
    xssec.requests.requestUserToken(loginToken, externalServiceCredentials, null, null, null, cb);
  } else {
    const tokenDecoded = jwtDecode(loginToken);
    requestUserToken(loginToken, externalServiceCredentials, tokenDecoded.zone_uuid, tokenDecoded.ext_attr && tokenDecoded.ext_attr.zdn, cb);
  }
}

function requestUserToken(appToken, serviceCredentials, zoneId, subdomain, cb) {
  let options;

  if (!serviceCredentials.domain) { // XSUAA
    const url = require('url');
    let urlWithCorrectSubdomain = serviceCredentials.url;
    const uaaUrl = url.parse(serviceCredentials.url);
    if (subdomain) {
      const tokenSubdomain = subdomain;
      let tokenRequestSubdomain = null;
      if (uaaUrl.hostname.indexOf('.') === -1) {
        tokenRequestSubdomain = null;
      } else {
        tokenRequestSubdomain = uaaUrl.hostname.substring(0, uaaUrl.hostname.indexOf('.'));
      }
      if (tokenSubdomain !== null && tokenRequestSubdomain !== null && tokenSubdomain !== tokenRequestSubdomain) {
        urlWithCorrectSubdomain = uaaUrl.protocol + '//' + tokenSubdomain + uaaUrl.host.substring(uaaUrl.host.indexOf('.'), uaaUrl.host.size);
      }
    } else if (zoneId) {
      urlWithCorrectSubdomain = uaaUrl.protocol + '//' + serviceCredentials.uaadomain;
    }

    options = {
      url: urlWithCorrectSubdomain + '/oauth/token',
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      form: {
        grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',
        response_type: 'token',
        client_id: serviceCredentials.clientid,
        assertion: appToken
      },
      auth: {
        user: serviceCredentials.clientid,
        pass: serviceCredentials.clientsecret
      },
      timeout: 10 * 1000
    };
    if (zoneId) {
      options.headers['x-zid'] = zoneId;
    }
  } else { // IAS
    options = {
      url: serviceCredentials.url + '/oauth2/token',
      headers: {
        Authorization: 'Basic ' + Buffer
            .from(serviceCredentials.clientid + ':' + serviceCredentials.clientsecret)
            .toString('base64'),
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      form: {
        grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',
        assertion: appToken
      },
      timeout: 10 * 1000
    };
  }

  request.post(
      options,
      function(error, response, body) {
        if (error) {
          return cb(error);
        }
        if (response.statusCode !== 200) {
          return cb(new Error(response.statusCode + ' - ' + body));
        }
        let json = null;
        try {
          json = JSON.parse(body);
        } catch (e) {
          return cb(e, null);
        }
        const token = json.access_token || json.id_token;
        return cb(null, token, json);
      }
  );
}
